import React, { useEffect, useRef, useState } from 'react';
import { OrbitControls, useAnimations, useGLTF, Float, useHelper, Sky } from '@react-three/drei';
import { Canvas, useFrame } from '@react-three/fiber';
import { Perf } from 'r3f-perf';
import { useControls } from 'leva';
import * as THREE from 'three';

const Experience = ({ foxPos }) => {
  const directionalLight = useRef();
  // useHelper(directionalLight, THREE.DirectionalLightHelper, 1);

  const { sunPosition } = useControls('sky', {
    sunPosition: { value: [1, 0.1, 3] },
  });

  return (
    <>
      <Perf position="top-left" />
      <directionalLight
        ref={directionalLight}
        position={sunPosition}
        intensity={1.5}
        castShadow
        shadow-mapSize={[1024, 1024]}
        shadow-camera-near={1}
        shadow-camera-far={10}
        shadow-camera-top={5}
        shadow-camera-right={5}
        shadow-camera-bottom={-5}
        shadow-camera-left={-5}
      />
      <Sky sunPosition={sunPosition} />
      <mesh receiveShadow position-y={-1} rotation-x={-Math.PI * 0.5} scale={100}>
        <planeGeometry />
        <meshStandardMaterial color="greenyellow" />
      </mesh>
      <Float speed={5} floatIntensity={3}>
        {foxPos.x && foxPos.y && <Fox foxPos={foxPos} />}
      </Float>
    </>
  );
};

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 Fox.gltf --transform
*/
const Fox = ({ foxPos }) => {
  const group = useRef();
  const fox = useGLTF('./Fox/glTF/Fox-transformed.glb');
  const animations = useAnimations(fox.animations, group);
  const [opacity, resetOpacity] = useFadeInOpacity(0.4);

  const { animationName } = useControls({
    animationName: { options: animations.names, value: 'Run' },
  });

  useEffect(() => {
    fox.materials.fox_material.transparent = true;
  }, []);
  
  useEffect(() => {
    fox.materials.fox_material.opacity = opacity;
  }, [opacity]);

  useEffect(() => {
    resetOpacity();
  }, [foxPos.x])

  useEffect(() => {
    const action = animations.actions[animationName];
    action.reset().fadeIn(0.5).play();
    return () => {
      action.fadeOut(0.5);
    };
  }, [animationName]);

  return (
    <group ref={group} dispose={null}>
      <group>
        <group name="root">
          <primitive
            object={fox.nodes._rootJoint}
            scale={0.02}
            position={[foxPos.x, foxPos.y + 1, -5]}
            rotation-y={0.3}
          />
          <skinnedMesh
            name="fox"
            castShadow
            receiveShadow
            geometry={fox.nodes.fox.geometry}
            material={fox.materials.fox_material}
            skeleton={fox.nodes.fox.skeleton}
          />
        </group>
      </group>
    </group>
  );
};

useGLTF.preload('./Fox/glTF/Fox-transformed.glb');

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 scene.gltf --transform
Author: James Allison (https://sketchfab.com/JamesA)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/the-elder-wand-efc7362a857749b3ae55fcbbba8baafb
Title: The Elder Wand
*/

const Wand = ({ mousePos }) => {
  const { nodes, materials } = useGLTF('./Wand/scene-transformed.glb');
  const ref = useRef();
  useFrame(() => {
    ref.current.position.set(mousePos.x, mousePos.y, mousePos.z);
  });
  return (
    <group dispose={null}>
      <group rotation={[-Math.PI / 2, 0, 0]} scale={1}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            ref={ref}
            castShadow
            receiveShadow
            geometry={nodes.Cylinder__0.geometry}
            material={materials['Scene_-_Root']}
            rotation={[-Math.PI / 4, -Math.PI / 2, -Math.PI / 4]}
            scale={0.1}
          />
        </group>
      </group>
    </group>
  );
};

useGLTF.preload('./Wand/scene-transformed.glb');

const ExperienceCanvas = () => {
  const cameraRef = useRef();
  const [mousePos, setMousePos] = useState([0, 0]);
  const [foxPos, setFoxPos] = useState([0, 0]);
  return (
    <div
      className="main-container"
      // Note(Benson): ChatGPT helped me here:
      onMouseMove={({ clientX, clientY }) => {
        const x = (clientX / window.innerWidth) * 2 - 1;
        const y = ((clientY / window.innerHeight) * 2 - 1) * -1;
        const mousePos = new THREE.Vector3(x, y, 0.5);
        mousePos.unproject(cameraRef.current);
        const direction = mousePos.sub(cameraRef.current.position).normalize();
        const distance = -cameraRef.current.position.z / direction.z;
        const newPos = cameraRef.current.position.clone().add(direction.multiplyScalar(distance));
        setMousePos(newPos);
      }}
      onMouseDown={({ clientX, clientY }) => {
        const x = (clientX / window.innerWidth) * 2 - 1;
        const y = ((clientY / window.innerHeight) * 2 - 1) * -1;
        const mousePos = new THREE.Vector3(x, y, -10);
        mousePos.unproject(cameraRef.current);
        const direction = mousePos.sub(cameraRef.current.position).normalize();
        const distance = -cameraRef.current.position.z / direction.z;
        const newPos = cameraRef.current.position.clone().add(direction.multiplyScalar(distance));
        setFoxPos(newPos);
      }}
    >
      <Canvas
        shadows
      >
        <perspectiveCamera ref={cameraRef} position={[0, 0, 7]} />
        <Wand mousePos={mousePos} />
        <Experience foxPos={foxPos} />
      </Canvas>
    </div>
  );
};

/*
Unnecessary but just wanted to fade in mesh.
*/
const useFadeInOpacity = (max) => {
  const timeoutRef = useRef();
  const [initialOpacity, setInitialOpacity] = useState(0);
  useEffect(() => {
    timeoutRef.current = setTimeout(() => {
      if (initialOpacity >= (max ?? 1)) {
        clearTimeout(timeoutRef.current);
        return;
      }
      setInitialOpacity(initialOpacity + 0.01);
    }, 500);
    return () => {
      clearTimeout(timeoutRef.current);
    };
  }, [initialOpacity]);
  return [initialOpacity, () => setInitialOpacity(0)];
};

export default ExperienceCanvas;
